<!DOCTYPE html>
<html>
<head>
<title>ReadMe.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<pre><code>     ॐ Kash Chauhan ॐ
</code></pre>
<h1 id="framework-from-scratch----playwright--typescript----opencart">Framework from Scratch --&gt; Playwright + TypeScript --&gt; OpenCart</h1>
<h2 id="install-playwright-first">Install Playwright first</h2>
<h2 id="steps">Steps:</h2>
<pre><code>    1. Install Dependencies (Packages)
    2. Project Folder Structure
    3. Update playwright.config.ts
    4. Create test.config.ts
    5. Create POM (Page Object Model) Classes, 9 files
    6. Create Test Data Files - create under test data folder -&gt; login.json and login.csv
    7. Utility files (utils) - reusable, dataProvider.ts and randomDataGenerator.ts
    8. Create Test cases
</code></pre>
<h2 id="step-1---dependencies-packages">Step: 1 -&gt; Dependencies (Packages):</h2>
<pre><code>  - npm install csv-parse
  - npm install xlsx
  - npm install -D allure-playwright
  - npm install @faker-js/faker 
</code></pre>
<h2 id="step-2---project-folder-structure">Step: 2 -&gt; Project Folder Structure</h2>
<pre><code>  - tests/                   -&gt; test files(cases)
  - pages/                   -&gt; Page Object Model (classes)
  - utils/                   -&gt; Utility Functions
  - data/                    -&gt; Test data files (JSON, CSV)
  - reports/                 -&gt; Generated test reports
  - test.config.ts           -&gt; Test configuration values
  - playwright.config.ts     -&gt; Playwright main configuration
  - package.json
</code></pre>
<h2 id="step-3---playwrightconfigts">Step: 3 -&gt; playwright.config.ts</h2>
<pre><code>  - Update all config as required
</code></pre>
<h2 id="step-4---testconfigts---reusable----open-url-credentials-product-details">Step: 4 -&gt; test.config.ts -&gt; reusable --&gt; open url, credentials, product details</h2>
<pre><code>  - this is class file for global test data
  - for common links, username, passwords, product details
  - we do not need to add these details every time
  - username: kash@xyz.com
  - password: test@123
</code></pre>
<h2 id="step-5---pom-page-object-model-classes">Step: 5 -&gt; POM (Page Object Model) Classes</h2>
<pre><code>  - Create files in the pages/ folder for each page:
      1. HomePage.ts
      2. RegistrationPage.ts
      3. LoginPage.ts
      4. LogoutPage.ts
      5. MyAccountPage.ts
      6. ProductPage.ts
      7. SearchResultsPage.ts
      8. ShoppingCartPage.ts
      9. CheckoutPage.ts

  - Each class should contain methods for interacting with UI elements of that page.


1. HomePage.ts --&gt; Click on My Account and Registration (Login)
  - import {Page, expect, Locator} from &quot;@playwright/test&quot;;
  - export class HomePage{ }
  - locators
  - constructor
  - action methods (try and catch method)
      - check if HomePage exists
      - click My Account Link
      - click Registration Link
      - click Login Link
      - enter Product name in the Searchbox
      - click Search Button

2. RegistrationPage.ts --&gt; Fill the form with all details
  - import {Page, expect, Locator} from &quot;@playwright/test&quot;;
  - export class HomePage{ }
  - locators
  - constructor
  - action methods for Registration form
      - Fill First Name
      - Fill Last Name
      - Fill Email
      - Fill Telephone
      - Fill Password
      - Fill Confirm Password
      - Check policy checkbox
      - Click continue button
      - Confirmation Message

3. LoginPage.ts 
  - import {Page, Locator} from '@playwright/test';
  - export class LoginPage { }
  - locators
  - constructor
  - action methods to login
    - Email address on Login page
    - Password on Login page
    - Click Login Button
    - complete login action (all methods in one)

4. MyAccountPage.ts
    - import {Page, Locator, expect} from '@playwright/test';
    - import { LogoutPage } from './LogoutPage';
    - locators
    - constructor
    - action methods
      - Verify if My Account Page is displayed (try and catch)
      - Click Logout link (try and catch)
      - Alternative method to return page exists using Title  

5. LogoutPage.ts
    - import {Page, Locator } from &quot;@playwright/test&quot;;
    - import { HomePage } from &quot;./HomePage&quot;;
    - locators
    - constructor
    - action methods
      - Click continue button after Logout
      - Verify Continue Button is visible 


6. ProductPage.ts
   - import { Page, Locator, expect} from &quot;@playwright/test&quot;;
   - import { ShoppingCartPage } from &quot;./ShoppingCartPage&quot;;
   - locators
   - constructor
   - action methods
      - Sets the Product Quantity
      - Add Product to Cart
      - Check if confirmation message is visible
      - Click on Items button to navigate to cart
      - Click on View Cart link
      - Complete workflow to add product to cart

7. SearchResultsPage.ts
   - import { Page, Locator } from &quot;@playwright/test&quot;;
   - import { ProductPage } from &quot;./ProductPage&quot;; 
   - locators
   - constructor
   - action methods
      - Verify if Search Results page exists by checking header text
      - Check if product exists in the search results by its name - parameter productName
      - Select product from search results by its name - parameter productName
      - Get count of the product in search results

8. ShoppingCartPage.ts
  - import { Page, Locator } from &quot;@playwright/test&quot;;
  - import { CheckoutPage } from &quot;./CheckoutPage&quot;; 
  - locators
  - constructor
  - action methods         
      - Get the total price from the shopping cart
      - Click on the Checkout button
      - Verify if shopping cart page is loaded

9. CheckoutPage.ts
  - import {Page, expect, Locator} from &quot;@playwright/test&quot;;
  - locators
  - constructor
  - action methods
      - Check if checkout page exists
      - Choose checkout option
      - Click on continue button
      - Form field methods
      - Continue button methods
      - Delivery method
      - Terms and conditions
      - Order confirmation
      - Handle alert if present
</code></pre>
<h2 id="step-6---add-test-data-files---create-under-test-data-folder">Step: 6 -&gt; Add Test Data Files - create under test data folder</h2>
<pre><code>  - logindata.json
  - logindata.csv
  - logindata.xl (generally we do not use)

  - use for data-driven testing
  - test data need to create only for scenario with multiple sets of data, no for every test case
  - every test case will not be the data driven
  - certain scenarios will need to test with different sets of data so only for them need to add test data files.


* logindata.json:
  - Two scenarios: valid and invalid credentials
  - valid: login should be successful.
  

* logindata.csv:
  - testName,email,password,expected
  - Valid login,kash@xyz.com,test@123,success
  - Invalid login,xyaere@xyz.com,abcxye,failure
</code></pre>
<h2 id="step-7---utility-files-utils---reusable">Step: 7 -&gt; Utility files (utils) - reusable</h2>
<pre><code>  - to read data from json and csv files, need to create one utility file
  - dataProvider.ts  - Read JSON and CSV data
  - randomDataGenerator.ts  - Generate dummy data using faker 

* dataProvider.ts:
  -  import fs and csv-parse/syn separately
  -  create two static functions in class
  -  one function will return data from JSON
  -  another function will return data from CSV 
  -  that data wil use in test case

* randomDataGenerator.ts:
  - faker library data
  - random data generate; i.e., name, address, phone, alphanumeric, numeric..
</code></pre>
<h2 id="step-8---test-cases-under-test-cases-folder">Step: 8 -&gt; Test Cases (under test cases folder)</h2>
<pre><code>  1. import  
  2. Declare shared variables
  3. Setup beforeEach hook
  4. Initialize page objects within beforeEach hook section
  5. Setup afterEach hook 
  6. Start test case steps (Scenario) 

* import: Example:
  
  import { test, expect } from &quot;@playwright/test&quot;;
  import { HomePage } from &quot;../pages/HomePage&quot;;
  import { MyAccountPage } from &quot;../pages/MyAccountPage&quot;;
  import { LoginPage } from &quot;../pages/LoginPage&quot;;
  import { LogoutPage } from &quot;../pages/LogoutPage&quot;;

  import { TestConfig } from &quot;../test.config&quot;; //to open URL


* Declare shared variables: Example:
  
  let config : TestConfig;
  let homePage : HomePage;
  let myAccountPage : MyAccountPage;
  let loginPage : LoginPage;
  let logoutPage : LogoutPage;


* Setup beforeEach hook: Example:
  
    test.beforeEach( async ({page}) =&gt; {

    config = new TestConfig(); //Load test config
    await page.goto(config.appUrl); //Step: 1  Open application URL
  
*  Initialize page objects inside beforeEach hook: Example:
    
    homePage = new HomePage(page);
    myAccountPage = new MyAccountPage(page);
    loginPage = new LoginPage(page);
    logoutPage = new LogoutPage(page);

  })

* Setup afterEach hook: Example:
  
    test.afterEach(async ({page}) =&gt; {
      await page.close(); //helps to keep tests clean

  })


* Start test case steps (Scenarios)


Tips:
* import class Names from file names given while creating
* hooks are required for more than one test block in same file to run before and after every test
* for password and confirm password, need to set in a variable, so that it will not generate different password for confirm password
* for check box no parameter needed, await registrationPage.policyCheckbox();
* for continue button, parameter needed, await registrationPage.continueButton();
* for confirmation message, expect(confirmationMsg).toContain('Your Account Has Been Created!')
* after completing all the test, need to integrate everything in package.json file and then start doing execution, so all the commands will need to configure in package.json file
* add await where needed
</code></pre>
<h2 id="hooks">Hooks:</h2>
<pre><code>  - beforeEach()
  - afterEach() //this is not mandatory, can just write await page.close()


  * beforeEach()
    - keep all common steps within this hook in each test file which has more than one test blocks; i.e,

      let homePage = HomePage; //global variable
      let registrationPage = RegistrationPage; //global variable

      test.beforeEach(async({page}) =&gt; {

        const config = new TestConfig ();
        await page.goto(config.appUrl); //navigate to url
        homePage = HomePage;
        registrationPage = RegistrationPage;

      });

      
  * afterEach () - write it just after beforeEach hook   
        i.e;

        test.afterEach (async ({page}) =&gt; {

          await page.close();

        })
</code></pre>
<h2 id="commands-to-generate-and-view-allure-reports-need-to-configure-in-playwrightconfigts-first">Commands to generate and view allure reports //need to configure in playwright.config.ts first</h2>
<pre><code>  allure generate ./allure-results -o ./allure-report --clean
  
  allure open ./allure-report

  **playwright.config.ts**
  reporter: [ 
    ['html', { outputFolder: '../reports/html-report' }], 
    ['allure-playwright', { outputFolder: '..reports/allure-results'}],
    ['dot'],
    ['list']
  ],
</code></pre>
<h2 id="run-tests-from-packagejson">Run tests from Package.json:</h2>
<pre><code>&quot;scripts&quot;: {
      &quot;test:end-to-end&quot;: &quot;playwright test --grep @end-to-end --headed&quot;,
      &quot;test:master&quot; : &quot;playwright test --grep @master&quot;,
      &quot;test:master:headed&quot;: &quot;playwright test --grep @master --headed&quot;,
      &quot;test:sanity&quot; : &quot;playwright test --grep @sanity&quot;,
      &quot;test:regression&quot; : &quot;playwright test --grep @regression&quot;,
      &quot;test:datadriven&quot; : &quot;playwright test --grep @datadriven&quot;,
      &quot;test:sanity:debug&quot; : &quot;playwright test --grep @sanity --debug&quot; 

  },

  - Need to use keyword only to run particular test

  * Run Test:
    npm run test:master:headed  //this will run all the test in headed mode
</code></pre>
<h2 id="data-driven-test">Data-Driven Test</h2>
<pre><code>  Data-driven testing means we have to repeat the same login (for example) with the multiple sets of data; we have to test the login with multiple sets of data

1. In test data folder create
  - logindata.json
    - In array two different blocks(Valid and Invalid scenarios) : test name, email, password, expected
    - Make sure same thing should not repeat again.
    - Keep the test name different every time, as based on the test name the test will repeat multiple times; otherwise, it will consider as duplicate 
    - Can add multiple combinations of tests as required 
  
  - logindata.csv
    - In three different lines (Valid and Invalid scenarios): test name, email, password, expected.
    - Make sure same thing should not repeat again.
    - Can add multiple combinations of tests as required


2. To read login.json and login.csv data,
  In util folder create
  - dataProvider.ts  --&gt; one class with two static functions ()


3. Crete data-driven test cases in tests
  * always import with class name 

  - import pages; HomePage, MyAccountPage, LoginPage
  - import TestConfig to get appUrl
  - import DataProvider to read json and csv data  

  - Load the data from file
      - Load one by one
      - Load Json data first -&gt; logindata.json
      - Need to provide the path of the file
        const jsonPath = &quot;testdata/logindata.json&quot;; //this is called json path

      - To load this data into a variable, we need to call the function which created in utils -&gt; dataProvider.ts -&gt; DataProvider (class name) -&gt; getTestDataFromJson (filePath:string) by passing the file path

          const jsonTestData = DataProvider.getTestDataFromJson(jsonPath)

      - then start writing looping statements because same login test need to repeat multiple times and json data returns array

        for (const data of jsonTestData) {

          test(`  `) //start writing test here with the backtick

        }    

      so from jsonTestData we are reading each data one by one and that data we need to use in test
</code></pre>
<h2 id="end-to-end-testing">End-to-End Testing</h2>
<pre><code>  - It is complete User flow
  - No need to add hooks in the actual end to end test
  - Need to hardcode password and at the end need to write return email to log in again after registration and logged out
  - Need to create separate functions for all steps of test case and call that functions in one test block

  - can get emojis by pressing windows key + . or  from chatGPT paste code and ask to generate emojis 


                                                                                                                          ©Kash Chauhan</code></pre>

</body>
</html>
